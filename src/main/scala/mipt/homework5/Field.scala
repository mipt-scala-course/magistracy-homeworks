package mipt.homework5

/**
Реализовать тайпкласс Field
  Поле - множество F, на котором:

  - определена операция сложения (+)
  - есть нейтральный элемент (0) относительно операции сложения
  - для любого элемента множества определен обратный элемент относительно сложения
  - определена операция умножения (*)
  - есть нейтральный элемент (1) относительно операции умножения (на F\{0})
  - для любого элемента кроме 0 определен обратный относительно операции умножения

  И выполнены законы:
    1) (F, +, 0) - коммутативная группа
    2) (F \ {0}, *, 1) - коммутативная группа
    3) дистрибутивность умножения относительно сложения:
      forall a, b, c: F => (a + b) * c = (a * c) + (b * c)
 */
trait Field[F] {
  // названия методов могут выбраны произвольны
  //  def zero...
  //  def one...
  //  def add...
  //  def mul...
  //  def addInv...
  //  def mulInv(x: F): Option[F]
}

object Field {
  /**
  Реализовать summoner для Field
    После реализации вместо `implicitly[Field[Foo]]` можно будет писать просто `Field[Foo]`
   */
  //  def apply...

  /**
  Реализовать инстанс поля для вещественных чисел
    На основе тайпкласса Fractional из стандартной библиотеки выводить инстанс Field

    Чтобы в скоупе всегда были инстансы
      Field[Double], Field[Float], Field[BigDecimal]
   */
  implicit def numericField[A: Fractional]: Field[A] = ???

  /**
  Релизовать инстанс поля для множества из двух элементов {true, false}
    Операция сложения - "исключающее или"
    Операция умножения - "и"
   */
  implicit val booleanField: Field[Boolean] = ???

  /**
  Реализовать метод создающий конечное поле остатков по модулю p, где p - простое
    На входе: p - простое
      1) не надо проверять что на входе действительно простое число
      2) если передать составное число в pField, то на выходе может быть любая некорректная структура
   */
  def pField(p: Int): Field[Int] = ???

  object syntax {
    /**
    Реализовать синтаксис для операций из тайпкласса Field
     */
    //    implicit class fieldSyntax...
    //      def +...
    //      def -...
    //      def *...
    //      def /...
  }
}